---

This work is licensed under the Creative Commons CC0 License

---

intro
  model-based testing
  vector space problem
  thesis
    automatic generation of tests by modeling sensor space
    automatic grading of resulting behavior by modeling application
    automatic generation of turbulence (noise)
    case study
    case study connected to test bench
automatic generation of tests by modeling sensor space
automatic grading of resulting behavior by modeling application
automatic generation of turbulence (noise)
case study
  GPS navigation
  model of navigation
  model of GPS sensor data
  test bench
conclusion
  restate problem

# Model-Based Testing for Self-Driving Cars Navigation
### xtUML Project Analysis Note

### Self-Driving Car Models

Self-driving cars pose challenges to testing.  The quantity and
magnitude of sensor inputs create an enormous test vector space.
Traditional manual testing methods are inadequate to cover this
multi-dimensional vector space with test cases.
To address this challenge model-based techniques are applied to manage the testing complexity.
Abstraction and automation increase the productivity of the test engineering.
Model-based test engineering allows generation of test cases, test data and predicted behavior.
Sensor test generation, automated navigation testing and turbulence induced testing are parts of a strategy to improve the efficiency of self-driving car testing.
A case study is provided as an example.

### Sensor Test Generation

A model-based engineering approach abstracts the sensors with models.
By modeling the sensors, automated test vector generation is enabled.
A component represents a functionality exposed through explicity interfaces.
Thus, the internal behavior of the component can be
abstracted and modeled using a variety of techniques including C coding,
Ruby scripting, Executable UML modeling or other methods of encoding behavior.

The interface to a sensor component provides a simple way of providing
input data to the application Navigation component.
The modeled interface between the Navigation application and the
sensor components enables injection of file-based test input data.
A standardized method of reading pre-recorded or pre-calculated sensor data
has been modeled and is part of the test bench modeling configuration.

### Test Generation for Navigation Application

When an application is modeled at an abstract level, its behavior is captured in a model that can be executed and tested.
This model predicts correct behavior based on correct input.
The same model can be used to detect and grade incorrect input.
Since the model does not physically crash like a vehicle in the real world, it can be used to explore erroneous data and used to develop recovery from bad sensor input.

The same model can be manipulated to _generate_ its own input.
Given a route, a Navigation application can automatically produce the sensor input that would cause the self-driving car to follow the route.
This capability can be used to automatically produce the massive quantity of test vector data needed to exercise the production system.

### Automatic Generation of Turbulence

The above elements can now be combined to produce test data that contains measured amounts of turbulence (noise).
With simple, abstract models of sensors and the application under test, we can automate the generation of tests including predictable levels of noise.
The ability to introduce turbulence into one or more sensors allows exploration of test scenarios involving faulty or noisy data coming from a combination of sensors.

:w



### 2. Document References

<a id="2.1"></a>2.1 [BridgePoint DEI #xxx1](https://support.onefact.net/issues/xxx1) TODO: Add description here.  
<a id="2.2"></a>2.2 [BridgePoint DEI #xxx2](https://support.onefact.net/issues/xxx2) TODO: Add description here.  
<a id="2.3"></a>2.3 [BridgePoint DEI #xxx3](https://support.onefact.net/issues/xxx3) TODO: Add description here.  

### 3. Background

In this section, outline the important points relating to this issue/bug that
the reader would need to know in order to understand the rest of this
document. Here is an example reference to the Document References section [[2.1]](#2.1)

![My Image](myimage.jpg)  

### 4. Requirements

This section describes the requirements that need to be satisfied.  If there 
is an SRS, this section may simply refer to it.  Each requirement should be as 
short and simple as possible and must be clearly defined. Here is an example reference to the Document References section [[2.1]](#2.1)

4.1 Item 1  
4.1.1 Example sub-item
* Example List Element
  * Example Sub list item

4.2 Item 2  
4.2.1 Example sub-item
* Example List Element

### 5. Analysis

This section is only required if there is no preceding analysis note. If present
it sets out a brief analysis of the problem to be resolved by this design note. Here is an example reference to the Document References section [[2.1]](#2.1)

5.1 Item 1  
5.1.1 Example sub-item
* Example List Element

5.2 Item 2  
5.2.1 Example sub-item
* Example List Element

### 6. Work Required

In this section, break out the consequential work (as a numbered list) needed
to meet the requirements specified in the Requirements section. Here is an example reference to the Document References section [[2.1]](#2.1)

6.1 Item 1  
6.1.1 Example sub-item
* Example List Element

6.2 Item 2  
6.2.1 Example sub-item
* Example List Element

### 7. Acceptance Test

In this section, list the tests that need to be performed in order to
verify that all the requirements are satisfied. Here is an example reference to the Document References section [[2.1]](#2.1)

7.1 Item 1  
7.1.1 Example sub-item
* Example List Element

7.2 Item 2  
7.2.1 Example sub-item
* Example List Element

### End
