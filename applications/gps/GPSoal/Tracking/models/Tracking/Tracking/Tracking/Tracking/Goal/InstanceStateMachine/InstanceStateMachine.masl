//! ACTIVITY BEGIN. '7fc80988-4415-437c-acc5-4c130cc2715d' '68a5f818-7dab-42d9-8593-79e79e2cc28b' DO NOT EDIT THIS LINE.
state Tracking::Goal.Executing () is
// Determine whether this goal is currently being achieved.
disposition = self.evaluateAchievement();

// Update achievement records if necessary.  There are four cases:
//   0. Still not achieving this goal. 
//   1. Just started achieving this goal.
//   2. Just stopped achieving this goal.
//   3. Still achieving this goal.
// For cases 0 and 3, there is nothing to be done for achievement records.
// Case 1 requires the creation of a new achievment record, storing the start time.
// Case 2 requires the storing of the end time for the open achievement record.
if ( (self.disposition != GoalDisposition::Achieving) and (disposition == GoalDisposition::Achieving) )
  // Case 1, create achievement record, store start time, relate it as open record.
  select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
  create object instance achievement of Achievement; achievement.startTime = workoutTimer.time;
  relate self to achievement across R14.'has_open';
elif ( (self.disposition == GoalDisposition::Achieving) and (disposition != GoalDisposition::Achieving) )
  // Case 2, store end time, relate as recorded record, unrelate as open record.
  select one achievement related by self->Achievement[R14.'has_open'];
  achievement.close();
end if;

// Update disposition of this goal.
self.disposition = disposition;

// Determine whether execution of this goal is complete, 
//  and if so, advance to the next one if it exists.
self.evaluateCompletion();
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7fc80988-4415-437c-acc5-4c130cc2715d' '4c799586-a213-493c-8525-7d7046820ad2' DO NOT EDIT THIS LINE.
state Tracking::Goal.Completed () is
// Stop executing this goal and begin executing the next one, if there is one.

// Stop the goal-evaluation timer, ignoring the return code which indicates 
//   whether a timer event was in flight when the timer was cancelled.
cancelSucceeded = TIM::timer_cancel( timer_inst_ref: self.evaluationTimer );

// If this goal has an open achievement record, close it.
select one openAchievement related by self->Achievement[R14.'has_open'];
if ( not empty openAchievement )
  openAchievement.close();
end if;

// Add this goal to the collection of those that have already executed.
select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
relate self to session across R13.'was_executed_within';

// Remove this goal from the collection of currently executing ones.
unrelate self from session across R11.'is_currently_executing_within';

// Find the next goal specification in the sequence and start executing it, if it exists.
select one currentGoalSpec related by self->GoalSpec[R9.'specified_by'];

select any nextGoalSpec related by session->GoalSpec[R10.'includes'] where ( selected.sequenceNumber == (currentGoalSpec.sequenceNumber + 1) );
  
if ( not empty nextGoalSpec )
  Goal::initialize( sequenceNumber: nextGoalSpec.sequenceNumber );
end if;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7fc80988-4415-437c-acc5-4c130cc2715d' 'e6accc06-aa6e-4858-b4ba-b47beb51fae5' DO NOT EDIT THIS LINE.
state Tracking::Goal.Paused () is
// Deactivate evaluation timer, ignoring the return code because this 
//   state model ignores any latent timer events.
cancelSucceeded = TIM::timer_cancel( timer_inst_ref: self.evaluationTimer );
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7fc80988-4415-437c-acc5-4c130cc2715d' '23f1d730-f476-4796-880d-ecae3d4f1985' DO NOT EDIT THIS LINE.
state Tracking::Goal.Evaluating () is
// Start a timer that periodically causes evaluation of goal achievement.
select any goalachievement from instances of GoalAchievement;
if ( empty goalachievement )
  GoalAchievement::initialize();
  select any goalachievement from instances of GoalAchievement;
end if;
create event instance evaluateEvent of Goal2:Evaluate to self; self.evaluationTimer = TIM::timer_start_recurring( event_inst: evaluateEvent, microseconds: goalachievement.evaluationPeriod );

generate Goal4:evaluationComplete() to self;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

