//! ACTIVITY BEGIN. '8ac30761-d43a-49d9-b7e4-c3ec442ea9f3' DO NOT EDIT THIS LINE.
public service Tracking::Goal.initialize ( sequenceNumber : in integer ) is
// Create and activate an instance of a goal specified by
//   the goal specification, if it exists, identified by 
//   the incoming parameter.

// Find the goal specification for this goal, then
//   create and relate this goal to the specification
//   and to the singleton workout session.
select any goalSpec from instances of GoalSpec where ( selected.sequenceNumber == param.sequenceNumber );
if ( not empty goalSpec )
  create object instance goal of Goal; goal.ID = goalSpec.last_goal_ID + 1;
  relate goal to goalSpec across R9.'specified_by';
  select any session from instances of WorkoutSession;  // WorkoutSession is a singleton
  relate goal to session across R11.'is_currently_executing_within';
  goalSpec.last_goal_ID = goal.ID;

  // Initialize this goal.
  goal.calculateStart();
  goal.disposition = GoalDisposition::Increase;

  // Start a timer that periodically causes evaluation of goal achievement.
  select any goalachievement from instances of GoalAchievement;
  if ( empty goalachievement )
    GoalAchievement::initialize();
    select any goalachievement from instances of GoalAchievement;
  end if;
  create event instance evaluateEvent of Goal2:Evaluate to goal; goal.evaluationTimer = TIM::timer_start_recurring( event_inst: evaluateEvent, microseconds: goalachievement.evaluationPeriod );
end if;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'b3215204-3d02-48ba-9794-25ddbc40009c' DO NOT EDIT THIS LINE.
public instance service Tracking::Goal.calculateStart () is
// Based on the span type for this goal, calculate and
//   store the value of the start attribute.
select one goalSpec related by self->GoalSpec[R9.'specified_by'];
if ( goalSpec.spanType == GoalSpan::Time )
  select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
  self.start = workoutTimer.time;
elif ( goalSpec.spanType == GoalSpan::Distance )
  select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
  self.start = session.accumulatedDistance;
else
  LOG::LogFailure( message: "Goal.calculateStart: Unknown Goal Span Type." );
end if;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '2b884ff8-637a-468b-a2fa-f96b8ef98b0a' DO NOT EDIT THIS LINE.
public instance service Tracking::Goal.evaluateAchievement () return GoalDisposition is
// Based on the type of goal, determine whether this one is 
//   currently being achieved and return a value indicating
//   the disposition of the this goal.    

// Find the related goal specification and workout session for this goal.
select one goalSpec related by self->GoalSpec[R9.'specified_by'];
select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];

// Based on the goal criteria type, get the appropriate current value
//   for comparison against the criteria (minimum and maximum).
currentValue = 0.0;  // Explicit declaration
if ( goalSpec.criteriaType == GoalCriteria::HeartRate )
  currentValue = session.getCurrentHeartRate();
elif ( goalSpec.criteriaType == GoalCriteria::Pace )
  currentValue = session.getCurrentPace();
else
  LOG::LogFailure( message: "Goal.evaluateAchievement: Unknown Goal Criteria Type." );
end if;
 
// Compare the current value against the criteria to calculate the return value.
goalDisposition = GoalDisposition::Achieving; 
if ( currentValue < goalSpec.minimum )
  goalDisposition = GoalDisposition::Increase;
elif ( currentValue > goalSpec.maximum )
  goalDisposition = GoalDisposition::Decrease;
end if;

// Invert the disposition value to produce a logical, semantic disposition for
//   goal types, such as pace, that require it.
if ( goalSpec.criteriaType == GoalCriteria::Pace )
  if ( goalDisposition == GoalDisposition::Increase )
    goalDisposition = GoalDisposition::Decrease;
  elif ( goalDisposition == GoalDisposition::Decrease )
    goalDisposition = GoalDisposition::Increase;
  end if;
end if;
 
return( goalDisposition );
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7090ad22-2865-4836-a89f-a46b868d3ac0' DO NOT EDIT THIS LINE.
public instance service Tracking::Goal.evaluateCompletion () is
// Based on the span type for this goal, determine 
//  whether it has been completed, update achievement
//  records as necessary, and advance to the next goal
//  if appropriate.

select one goalSpec related by self->GoalSpec[R9.'specified_by'];

// Based on the span type for the goal, get the elapsed span 
//   for comparison against the specified span for the goal.
elapsedSpan = 0.0;  // Explicit declaration
if ( goalSpec.spanType == GoalSpan::Distance )
  select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
  elapsedSpan = session.accumulatedDistance - self.start;
elif ( goalSpec.spanType == GoalSpan::Time )
  select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
  elapsedSpan = workoutTimer.time - self.start;
else
  LOG::LogFailure( message: "Goal.evaluateCompletion: Unknown Goal Span Type." );
end if;

// Compare the current value against the specified span to determine 
//   whether the execution of this workout goal is complete.
if ( elapsedSpan >= goalSpec.span )
  select one openAchievement related by self->Achievement[R14.'has_open'];
  if ( not empty openAchievement )
    openAchievement.close();
  end if;
  generate Goal1:Completed to self;
end if;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '902f97d2-b056-4461-89c5-6454f9f253d7' DO NOT EDIT THIS LINE.
public service Tracking::Goal.nextGoal () is
// Advance to the next goal or start the first one if one
//   is currently not exectuing.

//  If there is a goal currently executing, notify it that its execution
//    has completed.
//  Otherwise, create and start a goal for the first goal specification
//    if one exists.
select any gsc from instances of GoalSpecConstants;
if ( empty gsc )
  GoalSpecConstants::initialize();
  select any gsc from instances of GoalSpecConstants;
end if;
select any session from instances of WorkoutSession;  // WorkoutSession is a singleton.
if ( not empty session )
  select one goal related by session->Goal[R11.'is_currently_executing'];
  if ( not empty goal )
    generate Goal1:Completed to goal;
  else
    Goal::initialize( sequenceNumber: gsc.GoalSpecOrigin );
  end if;
end if;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

